---
title: brainfuck을 고수준에서 프로그래밍해보자(0)
date: 2022-03-14 11:48:00 +0900
tags: [난해한_프로그래밍_언어, 파이썬, 프로그래밍]
---

## 서론
brainfuck은 수많은 난해한 프로그래밍 언어들 사이에서 아마도 가장 유명한 축에 속할 것이다.

[이전 글]( https://gabriel-dropout.github.io/posts/Brainfuck-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0)

에서 소개된 적 있듯이 brainfuck은 8가지의 명령어만 사용하는 매우 단순한 문법을 가지고 있는데, __이런 단순한 문법에도 불구하고__ 메모리 크기가 물리적으로 무한할 수는 없다는 사소한 문제를 눈감아 준다면 튜링 완전한, 즉 __일반적인 컴퓨터와 동일한 계산 능력을 가진다.__

따라서 이론적으로는 어떠한 프로그램이든지 brainfuck으로 구현이 가능한데, 실제로는 문제가 하나 있다. 바로 골때리게 저수준인 문법 덕분에 `Hello World!` 출력 이상의 프로그램을 작성하려 하면 머리가 아파진다는 것. 정확히 말하자면 이전 글에서 볼 수 있듯이 `Hello World!` 출력조차도 효율적으로 작성하려고 하면 머리가 아파지기 시작한다. 그렇다면 더 고수준인 프로그래밍 언어로 프로그램을 작성한 뒤, 그 코드를 brainfuck으로 번역할 수 있다면 어떨까?

## 목표
이 주제는 대충 생각해봐도 매우 어려워 보인다.

1. 일단 brainfuck으로 민감한 __반복문__ 이나 __조건문__ 을 구현하는 방법을 알아내고,

2. 그것을 알고리즘이 자동적으로 만들어 낼 수 있도록 해야 하며,

3. brainfuck보다 고수준인 언어를 해석하는 코드를 작성해야 한다.

다시 말해, 일반적으로 인터프리터 언어를 구현할 때 해야 하는 작업들에 더해서 brainfuck까지 다루어야 한다는 것이다. 따라서 우선은 몇 가지 최소한의 목표만을 세워두고 앞으로 차차 더해가면서 발전시켜 나가기로 하자.

그 최소한의 목표는 바로

---

- 언어의 자료형은 정수만 지원한다(문자열은 아스키 코드를 이용해 출력하거나 단순 출력문에만 직접적으로 사용할 수 있도록 한다).

- 결과물로 나오는 brainfuck 코드의 최적화에는 신경쓰지 않고 일단은 작동이 잘 되는 것에만 신경쓴다.

- 결과물로 나오는 brainfuck 코드가 백준의 brainfuck 인터프리터와 8bit 셀을 지원하는 일반적인 brainfuck 인터프리터 양쪽 모두에서 작동될 수 있도록 한다.

---

이다.

 애초에 이 프로젝트를 시작하게 된 이유가 백준에서 아직 아무도 brainfuck으로 풀지 않은 문제들을 풀고 싶기 때문이어서, 세 번째 목표는 꼭 달성되어야 한다.

 백준의 brainfuck 인터프리터는 많은 brainfuck 커뮤니티에서 표준으로 간주되는 8bit 셀을 이용하지 않고 더 큰 자료형을 이용해 brainfuck 코드를 실행하는 것으로 추정되는데, 이 때문에 해외의 brainfuck 커뮤니티에서 wrapping이라고 부르는,  __0 - 1 = 255로 처리되는 트릭을 사용할 수 없다__ ([이전 글]( https://gabriel-dropout.github.io/posts/Brainfuck-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0)에서 96byte로 백준의 hello world! 출력 문제에서 숏코딩 신기록을 세울 뻔 했지만 아쉽게도 좌절된 이야기로 언급되고 있다).

 또한, 일반적인 brainfuck 인터프리터와의 호환성을 위해서 256 이상의 수를 한 셀에 저장할 수는 없기 때문에 정수 저장은 여러 셀에 256진법을 이용해 저장하기로 하자.


## 언어 설계
사실 결과물로 brainfuck 코드를 내놓는 트랜스파일러를 만드려는 시도는 당장에 구글링만 해보아도 엄청나게 많다는 것을 알 수 있다.

[한 깃허브 프로젝트](https://github.com/felko/bfpy)

를 보면, 파이썬 코드 자체를 해석하지도 않고 파이썬의 dis 모듈을 이용해 파이썬 코드가 인터프리터 내부에서 변환된 바이트코드를 가져와 마치 brainfuck이 스택머신인 것처럼 스택머신의 동작을 그대로 시뮬레이션 하는 방식으로 작동하도록 한다.

하지만 이 프로젝트에서는 이러한 방식을 사용하지 않고 밑바닥부터 고수준 언어 해석기를 구현할 것이며, 그렇다면 굳이 기존 언어의 문법을 그대로 가져올 필요 없이 새로운 언어를 설계해보는 것도 의미 있을 것이다. 위에서 언급한 최소한의 목표를 만족하는 수준 안에서 새로운 고수준 언어를 설계하여 사용할 것이다.

먼저 이 새로운 언어에 이름을 붙여야 한다. 이전에 만들었던 bf++(brainfuck 코드에서 반복되는 감산 및 가산 명령, 예를 들어 `+++++`를 `+5`로 축약해 쓸 수 있도록 만든 brainfuck 수정판, 사실 `+n`과 `-n`을 n개의 `+` 및 `-`로 바꾸어 줄 뿐이기에 무언가 만들었다고 하기도 애매하다.)를 이어서 bf#로 할까도 생각해 보았으나 그다지 느낌이 없다. 그래서 생각해 낸 이름은 바로

> "OCTO"

이렇게 이름을 지은 이유는 brainfuck이 8개의 명령어만을 사용하기 때문이다.

이제 문법에 대해 이야기를 하자면,

OCTO의 프로그래밍 패러다임은 분류하자면 함수형 프로그래밍이 될 것이다. 이때까지 함수형 프로그래밍 언어를 써 본 경험이라고는 Lisp를 가지고 잠깐 놀아본 것 밖에 없고, 꼬리 재귀는 한 번도 써 본적이 없지만 굳이 함수형 프로그래밍으로 패러다임을 정한 것에는 다 이유가 있다.

 __첫 번째,__ 함수형 프로그래밍 언어에서는 다른 프로그래밍 패러다임을 가진 언어와는 다르게 한 번 설정된 변수는 값을 바꿀 수 없어 사실상 상수함수와 같다는 점이다. 한 번 사용된 변수가 바뀌지 않는다는 것은 brainfuck 레벨에서 처리가 일어날 때 상당히 구현을 편하게 해 줄 것이라고 생각했다.

 __두 번째,__ 재귀적인 방법을 사용해 `for`이나 `while`문을 대체할 수 있다는 것이다. 사실 이것은 첫 번째 이유와는 달리 구현의 편의성 때문이라기 보다는 순전히 미학적인 관점(?)에서 생겨난 이유인데, 바로 리스트의 구현이 아직 목표에 없는 현 상황에서 유일한 대안인 C-like식 `for`문은 모양이 예쁘지 않기 때문이다. 예전부터 프로그래밍 언어를 새로 구현한다면 가능한 적은 키워드를 사용하는 언어였으면 좋겠다고 생각해 왔기 때문에 `for`, `while`이나 이것에서 파생되는 `continue`, `break`같은 키워드까지 없애버릴 수 있다는 것은 굉장히 매력적인 선택지였다.


```clike
func hello():
    puts('hello world!')

func repet(int n):
    if n > 0:
        hello()
        repet(n - 1)

func main():
    int n = int(gets())
    repet(n)
```

위의 코드는 반복문 없이 재귀적인 방법으로 입력받은 횟수만큼 `hello world!`를 출력하도록 하는 코드이다. OCTO의 코드는 위와 같은 형태가 될 예정인데, 들여쓰기를 사용해 블럭 구분을 하는 등 파이썬에서 마음에 들었던 요소들을 가지고 왔다.

사실 프로그래밍 패러다임이 함수형 프로그래밍이라는 것과 구현 상의 편의성을 위해 자료형을 정적으로 관리할 것이라는 것을 빼면 OCTO의 문법은 몇몇 키워드를 제외하고 파이썬과 비슷하게 만들 예정이라는 것을 밝히면서, 문법에 관한 자세한 설명은 실제 구현에 관한 내용이 시작되는 다음 글로 미루도록 하겠다. 다음 글에는 어쩌면 문법이 조금 바뀌어 있을지도 모르겠다.

---

그럼 오늘은 여기까지!